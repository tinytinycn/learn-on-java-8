# 并发编程

## 术语问题

1. Brian Goetz 在他 2016 年《从并发到并行》的演讲中指出了这一点，之后提出了合理的区分：

    - 并发是关于正确有效地控制对共享资源的访问。
    - 并行是使用额外的资源来更快地产生结果。

> “并发”通常表示：”不止一个任务正在执行“。而“并行”几乎总是代表：”不止一个任务同时执行“。现在我们能立即看出这些定义中的问题所在：“并行”也有不止一个任务正在执行的语义在里面。区别就在于细节：究竟是怎么“执行”的。此外还有一些重叠：为并行编写的程序依旧可以在单处理器上运行，而并发编写的系统也可以利用多个处理器。

2. 还有另一种解释：

    - 并发，同时完成多任务。无需等待当前任务完成即可执行其他任务。并发解决了程序因外部原因开支而无法进一步执行的阻塞问题。例如，IO操作，任务必须等待数据输入（常见于IO密集型任务）。
    - 并行，同时在多个位置完成多任务。并行解决了CPU密集型任务，将程序分为多个部分，在多个处理器上同时处理不同部分来加快程序执行效率。

Java 在内的许多编程语言使用相同的机制 -- 使用"线程"来实现并发和并行。

3. 尝试以更细的粒度去定义（然而这并不是标准化的术语）：

    - 纯并发，在单个CPU上运行任务。纯并发系统比时序系统更快产生结果，但它的运行速度不回因为处理器的增加而变得更快。
    - 并发-并行，使用并发技术，结果程序可以利用多处理器更快地产生结果。
    - 并行-并发，使用并行编程技术，即使只有一个处理器，结果程序仍然可以运行。（例如，Java8 Streams）
    - 纯并行，只有在多个处理器的情况才能运行。

## 并发的新定义

并发性是一系列专注于减少等待的性能技术

- 并发，包含了不同的方法来解决这个问题。
- 并发的关键点在于让你的程序运行得更快。
- 无论你的程序运行在多少个处理器上，你只能在"等待"发生时才能产生效益。例如，发起IO请求并立即获得结果，没有延迟则无需改进；如果在多个处理器上处理多个任务，每个处理器满容量运行，没有任务需要等待其他任务，那么提高吞吐量是没有意义的。
- 并发的唯一机会是程序的某部分被迫等待。等待会以多种形式出现，这解释了为什么存在多种不同的并发方法。

## 并发的超能力

想象一个场景：你必须在一栋大楼中找到一个东西，它被隐藏在大楼里面千万个房间的一间，你沿着走廊一间一间的查找。每次打开一扇门之前你都需要敲一次门等待一会。

想象你拥有一种能力：克隆自己，复制一个克隆人帮你查找东西。

理论情况：每次克隆自己，都需要一个物理处理器运行克隆搜索者。

实际情况：机器的处理器核心是有限的个数。（4或8个处理器等等）

思考一：单核处理器，在多个任务之间切换的成本也是由此核心承担。你可能认为将并发技术应用于单核处理器会使得它运行得更慢。但是某些情况下，并发模型会产生更简单的代码。如果运行过程中遇到了程序之外的等待，单核处理器也能从并发技术中获益。
思考二：单核处理器，如果程序运行的任务一直需要占用CPU，那么并发技术并不能是你从中获益。只能在多核处理器中使用并发技术，从而获益。
思考三：多核处理器，如果程序运行了多个线程，每个线程任务持续占用CPU，这种情况下，线程数应该和处理器核心数保持一致。

## 并发为速度而生

如果你想要一个程序运行得更快，将其分解为多个部分，并在单独的处理器上运行每个部分。随着提高时钟速度的能力耗尽，速度的提高是出现在多核处理器的形式而不是更快的芯片。你需要充分利用额外的处理器，来提高程序运行速度。

- 多核处理器，可以在处理器之间分配任务，可以显著提高吞吐量
- 单核处理器，也可以使用并发技术，提高运行程序的性能。从表面上看，将程序的所有部分作为单个任务运行，并且节省上下文切换的成本，这样看似乎更划算。但程序的某个任务由于"程序控制之外的原因"
  而无法继续，必须等待（通常是IO等待），我们称该任务或线程已经阻塞。我们使用并发技术便携程序，让一个任务被阻塞时，能够切换到其他任务继续执行。
- 事实上，从性能角度考虑看，如果没有任务阻塞（例如，CPU密集型任务），那么单核处理器上使用并发是没有意义的。

实现并发的一种简单方式是使用操作系统级别的进程。与线程不同，进程是在其自己的地址空间中运行的独立程序。进程的优势在于，因为操作系统通常将一个进程与另一个进程隔离，因此它们不会相互干扰，这使得进程编程相对容易。相比之下，线程之间会共享内存和
I/O 等资源，因此编写多线程程序最基本的困难，在于协调不同线程驱动的任务之间对这些资源的使用，以免这些资源同时被多个任务访问。

有些人甚至提倡将进程作为唯一合理的并发实现方式1，但遗憾的是，通常存在数量和开销方面的限制，从而阻止了进程在并发范围内的适用性。

Java 采用了更传统的方法2，即在顺序语言之上添加对线程的支持而不是在多任务操作系统中分叉外部进程，线程是在表示执行程序的单个进程内创建任务。

并发会带来各种成本，包括复杂性成本，但可以被程序设计、资源平衡和用户便利性方面的改进所抵消。通常，并发性使你能够创建更低耦合的设计；另一方面，你必须特别关注那些使用了并发操作的代码。

## Java 创建和运行线程

- extends Thread线程类
- implement Runnable接口
- Executors.newSingleThreadExecutor()/newCachedThreadPool()/newFixedThreadPool()
- 结合CompletableFuture

## Java 线程状态

- New：新创建的线程，尚未执行；
- Runnable：运行中的线程，正在执行run()方法的Java代码；
- Blocked：运行中的线程，因为某些操作被阻塞而挂起；
- Waiting：运行中的线程，因为某些操作在等待中；
- Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待；
- Terminated：线程已终止，因为run()方法执行完毕。